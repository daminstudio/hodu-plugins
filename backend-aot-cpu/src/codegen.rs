//! C code generation from Hodu Snapshots

mod binary;
mod cast;
mod concat_split;
mod conv;
mod indexing;
mod matrix;
mod memory;
mod reduce;
mod shape;
mod unary;
mod windowing;

use hodu_cli_plugin_sdk::{ops::Op, snapshot::SnapshotNode, PluginResult, Snapshot};
use hodu_core::types::DType;
use std::fmt::Write;

pub fn generate(snapshot: &Snapshot) -> PluginResult<String> {
    let mut code = String::new();

    write_header(&mut code);
    write_constants(&mut code, snapshot);
    write_model_function(&mut code, snapshot)?;

    Ok(code)
}

fn write_header(code: &mut String) {
    writeln!(code, "// Auto-generated by hodu aot-cpu backend").unwrap();
    writeln!(code, "#include \"storage.h\"").unwrap();
    writeln!(code, "#include \"ops_binary.h\"").unwrap();
    writeln!(code, "#include \"ops_unary.h\"").unwrap();
    writeln!(code, "#include \"ops_matrix.h\"").unwrap();
    writeln!(code, "#include \"ops_reduce.h\"").unwrap();
    writeln!(code, "#include \"ops_conv.h\"").unwrap();
    writeln!(code, "#include \"ops_concat_split.h\"").unwrap();
    writeln!(code, "#include \"ops_indexing.h\"").unwrap();
    writeln!(code, "#include \"ops_windowing.h\"").unwrap();
    writeln!(code, "#include \"ops_cast.h\"").unwrap();
    writeln!(code, "#include \"ops_memory.h\"").unwrap();
    writeln!(code, "#include <stdlib.h>").unwrap();
    writeln!(code).unwrap();
}

fn write_constants(code: &mut String, snapshot: &Snapshot) {
    if snapshot.constants.is_empty() {
        return;
    }
    writeln!(code, "// Constants").unwrap();
    for constant in &snapshot.constants {
        write!(code, "static const unsigned char c{}_data[] = {{", constant.id.0).unwrap();
        for (i, byte) in constant.data.iter().enumerate() {
            if i % 16 == 0 {
                write!(code, "\n    ").unwrap();
            }
            write!(code, "0x{:02x},", byte).unwrap();
        }
        writeln!(code, "\n}};").unwrap();
    }
    writeln!(code).unwrap();
}

fn write_model_function(code: &mut String, snapshot: &Snapshot) -> PluginResult<()> {
    let name = snapshot
        .name
        .as_deref()
        .unwrap_or("model")
        .replace(|c: char| !c.is_alphanumeric() && c != '_', "_");

    let max_id = snapshot
        .nodes
        .iter()
        .map(|n| n.output_id.0)
        .chain(snapshot.inputs.iter().map(|i| i.id.0))
        .chain(snapshot.constants.iter().map(|c| c.id.0))
        .max()
        .unwrap_or(0)
        + 1;

    writeln!(code, "void {}_run(void** inputs, void** outputs) {{", name).unwrap();
    writeln!(code, "    void* t[{}];", max_id).unwrap();
    writeln!(code).unwrap();

    // Inputs
    for (i, input) in snapshot.inputs.iter().enumerate() {
        writeln!(code, "    t[{}] = inputs[{}];", input.id.0, i).unwrap();
    }
    // Constants
    for constant in &snapshot.constants {
        writeln!(code, "    t[{}] = (void*)c{}_data;", constant.id.0, constant.id.0).unwrap();
    }
    writeln!(code).unwrap();

    // Nodes
    for (idx, node) in snapshot.nodes.iter().enumerate() {
        write_node(code, node, idx)?;
    }
    writeln!(code).unwrap();

    // Outputs
    for (i, target) in snapshot.targets.iter().enumerate() {
        writeln!(code, "    outputs[{}] = t[{}];", i, target.id.0).unwrap();
    }

    writeln!(code, "}}").unwrap();
    Ok(())
}

fn write_node(code: &mut String, node: &SnapshotNode, idx: usize) -> PluginResult<()> {
    // Allocate output (except for shape ops which may reuse input)
    let needs_alloc = !matches!(node.op, Op::Shape(_) | Op::Memory(_));
    if needs_alloc {
        let out_numel: usize = node.output_layout.shape().dims().iter().product();
        let elem_size = node.output_dtype.size_in_bytes();
        writeln!(code, "    t[{}] = malloc({});", node.output_id.0, out_numel * elem_size).unwrap();
    }

    match &node.op {
        Op::Binary(op) => binary::write(code, node, idx, *op),
        Op::BinaryLogical(op) => binary::write_logical(code, node, idx, *op),
        Op::Cmp(op) => binary::write_cmp(code, node, idx, *op),
        Op::CmpScalar(op) => unary::write_cmp_scalar(code, node, idx, *op),
        Op::Unary(op) => unary::write(code, node, idx, *op),
        Op::UnaryLogical(op) => unary::write_logical(code, node, idx, *op),
        Op::UnaryScalar(op) => unary::write_scalar(code, node, idx, *op),
        Op::Matrix(op) => matrix::write(code, node, idx, *op),
        Op::Reduce(op) => reduce::write(code, node, idx, *op),
        Op::Concat(op) => concat_split::write_concat(code, node, idx, *op),
        Op::Split(op) => concat_split::write_split(code, node, idx, *op),
        Op::Indexing(op) => indexing::write(code, node, idx, *op),
        Op::Conv(op) => conv::write(code, node, idx, *op),
        Op::Windowing(op) => windowing::write(code, node, idx, *op),
        Op::Shape(op) => shape::write(code, node, idx, *op),
        Op::ShapeScalars(op) => shape::write_scalars(code, node, idx, *op),
        Op::Cast(op) => cast::write(code, node, idx, *op),
        Op::Memory(op) => memory::write(code, node, idx, *op),
        Op::Dummy => Ok(()),
    }
}

pub fn dtype_suffix(dtype: DType) -> &'static str {
    match dtype {
        DType::BOOL => "bool",
        DType::F8E4M3 => "f8e4m3",
        DType::F8E5M2 => "f8e5m2",
        DType::BF16 => "bf16",
        DType::F16 => "f16",
        DType::F32 => "f32",
        DType::F64 => "f64",
        DType::U8 => "u8",
        DType::U16 => "u16",
        DType::U32 => "u32",
        DType::U64 => "u64",
        DType::I8 => "i8",
        DType::I16 => "i16",
        DType::I32 => "i32",
        DType::I64 => "i64",
    }
}

pub fn write_metadata(code: &mut String, name: &str, values: &[usize]) {
    write!(code, "    size_t {}[] = {{", name).unwrap();
    for (i, v) in values.iter().enumerate() {
        if i > 0 {
            write!(code, ",").unwrap();
        }
        write!(code, "{}", v).unwrap();
    }
    writeln!(code, "}};").unwrap();
}
